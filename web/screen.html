<script
  type="text/javascript"
  src="https://www.airconsole.com/api/airconsole-1.8.0.js"
></script>

<link rel="stylesheet" href="/css/css.css" />
<link rel="stylesheet" href="/css/screen.css" />

<!DOCTYPE html>
<script src="build/wasm_exec.js"></script>
<script>
// Polyfill
if (!WebAssembly.instantiateStreaming) {
    WebAssembly.instantiateStreaming = async (resp, importObject) => {
        const source = await (await resp).arrayBuffer();
        return await WebAssembly.instantiate(source, importObject);
    };
}

// Create a new instance of the Go WASM loader to load the game
const go = new Go();
WebAssembly.instantiateStreaming(fetch("build/game.wasm"), go.importObject).then(result => {
    go.run(result.instance);
});
</script>

<script type="text/javascript">
  // Set up some config 
  const minPlayers = 1;
  const maxPlayers = 3;

  // Set up some variables for state
  let airconsole;
  let activePlayers = [];
  let paused = false;
  let initialized = false;

  // This should be callable from the Go code
  function changeControllerScreen(screen) {
    // Update the state of the controller screen
    if(!airconsole) {
      console.error("AirConsole not initialized");
      return;
    }
    airconsole.setCustomDeviceStateProperty("screen", screen);
  }

  setupAirConsole();
  function setupAirConsole() {
    airconsole = new AirConsole({ silence_inactive_players: true });

    // Listen for pause and resume events
    airconsole.onPause = function () {
      paused = true;
      // Send pause event to the game via the JS/GO binding
      passPauseToGame();
    };
    airconsole.onResume = function () {
      paused = false;
      // Send resume event to the game via the JS/GO binding
      passResumeToGame();
    };
    
    // Listen for device connect and disconnect events
    airconsole.onConnect = function (deviceId) {
      // Here we can do any logic we want when a new device connects, such as checking that enough players have joined.
      if(!initialized) {
        // Do any actions that should only be done once here (on first device connect)
        initialized = true;
      }

      // We might want to prevent this handlePlayers from being called while a game is active (not in the lobby)
      // to prevent player index reshuffling while in-play (suddenly controlling another persons screen while playing is not great.)
      handlePlayers(); // This will set the number of active players, limited to the maxPlayers amount
    };
    airconsole.onDisconnect = function (deviceId) {
      // Here we can do any logic we want when a device disconnects, such as checking if the game should end.

      // We might want to prevent this handlePlayers from being called while a game is active (not in the lobby)
      // to prevent player index reshuffling while in-play (suddenly controlling another persons screen while playing is not great.)
      handlePlayers();
    };

    // Listen for messages from other devices
    airconsole.onMessage = function (from, data) {
      let playerId = airconsole.convertDeviceIdToPlayerNumber(from);
      // Check if device is an active player
      if(!activePlayers.includes(from)) {
        console.log("Device is not an active player");
        return;
      }

      // Send our custom input events received from the controllers to the game
      if(data.type === "input") {
        // Pass the action to the game via the JS/GO binding
        passInputToGame(playerId, data.input, data.direction);

        console.log("Player: " + (playerId + 1) + " Action received: " + data.input + " Direction: " + data.direction);
        airconsole.message(from, "Action received!");
      }
    };
  }

  // Function to handle the number of players connected
  // Limits the number of active players to the maxPlayers amount
  // Sets the activePlayers array to the active player device IDs
  function handlePlayers() {
    // Create copy of active players for comparison
    var oldActivePlayers = activePlayers;

    var connectedControllers = airconsole.getControllerDeviceIds();

    let validPlayersCount = connectedControllers.length > maxPlayers
            ? maxPlayers
            : airconsole.getControllerDeviceIds().length;

    airconsole.setActivePlayers(validPlayersCount);
    
    activePlayers = airconsole.getActivePlayerDeviceIds();    

    // If the number of active players has changed, communicate this to the game
    // This will currently always return the highest new/old player ID. 
    // E.g. if player 1 disconnects, it will re-index them and communicate that player 2 left, and player 2 becomes player 1
    // This is simply because of how airConsole getActivePlayerDeviceIds handles this. It will always re-index the player numbers for the device IDs.
    // Not sure how airconsole expects us to handle this such that the players don't swap characters when one disconnects.
    // Might have to implement some custom logic to handle this instead of using their solution.
    if(oldActivePlayers.length !== activePlayers.length) {
      var newPlayers = activePlayers.length - oldActivePlayers.length;
      if(newPlayers > 0) {
        for(playerId = activePlayers.length - newPlayers; playerId <= activePlayers.length; playerId++) {
          controllerConnectToGame(playerId);
          // In the future we will also need to update every player in the Go game to have the correct name
          // Otherwise the name would get "taken along" when the players swap
        }
      } else if(newPlayers < 0){
        removedPlayers = Math.abs(newPlayers);
        for(playerId = oldActivePlayers.length - removedPlayers; playerId <= oldActivePlayers.length; playerId++) {
          controllerDisconnectFromGame(playerId); 
        }
      }
    }
  }

  // Function to get player details from a device ID
  function getPlayerDetails(deviceId) {
    let playerId = airconsole.convertDeviceIdToPlayerNumber(deviceId);
    let name = airconsole.getNickname(deviceId);
    let profilePicture = airconsole.getProfilePicture(deviceId);
    let customData = airconsole.getCustomDeviceState(deviceId);
    let active = airconsole.getActivePlayerDeviceIds().includes(deviceId);

    return {
      playerId: playerId,
      name: name,
      profilePicture: profilePicture,
      customData: customData,
      active: active,
    };
  }
</script>
